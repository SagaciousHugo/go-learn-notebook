# 2.3 åŸºæœ¬æ•°æ®ç±»å‹

| é¢„å®šä¹‰ç±»å‹ | bitæ•° | é›¶å€¼ | è¯´æ˜ |
| :--- | :--- | :--- | :--- |
| int | 32/64 | 0 | è‡ªåŠ¨åŒ¹é…æ“ä½œç³»ç»Ÿä½æ•°ï¼Œ32ä½ç³»ç»Ÿç­‰ä»·äºint32ï¼Œ64ä½ç³»ç»Ÿç­‰ä»·äºint64 |
| int8 | 8 | 0 | 8bit æ•´æ•° |
| int16 | 16 | 0 | 16bit æ•´æ•° |
| int32 | 32 | 0 | 32bit æ•´æ•° |
| int64 | 64 | 0 | 64bit æ•´æ•° |
| uint | 32/64 | 0 | è‡ªåŠ¨åŒ¹é…æ“ä½œç³»ç»Ÿä½æ•°ï¼Œ32ä½ç³»ç»Ÿç­‰ä»·äºuint32ï¼Œ64ä½ç³»ç»Ÿç­‰ä»·äºuint64 |
| uint8 | 8 | 0 | 8bit æ— ç¬¦å·æ•´æ•° |
| uint16 | 16 | 0 | 16bit æ— ç¬¦å·æ•´æ•° |
| uint32 | 32 | 0 | 32bit æ— ç¬¦å·æ•´æ•° |
| uint64 | 64 | 0 | 64bit æ— ç¬¦å·æ•´æ•° |
| uintptr | 32/64 | 0 | ä¸€ä¸ªè¶³å¤Ÿå¤§çš„æ— ç¬¦å·æ•´å‹ï¼Œç”¨æ¥è¡¨ç¤ºä»»æ„åœ°å€ |
| float32 | 32 | 0.0 | 32bitæµ®ç‚¹æ•° |
| float64 | 64 | 0.0 | 64bitæµ®ç‚¹æ•° |
| complex64 | 64 | 0.0 + 0.0i | å¤æ•°ï¼Œå®éƒ¨float32  è™šéƒ¨float32 |
| complex128 | 128 | 0.0 + 0.0i | å¤æ•°ï¼Œå®éƒ¨float64 è™šéƒ¨float64 |
| bool | 8 | false | å¸ƒå°”å‹ |
| byte | 8 | 0 | å­—èŠ‚ï¼Œint8çš„åˆ«å |
| rune | 32 | 0 | utf-8å­—ç¬¦ï¼Œint32çš„åˆ«å |
| string | ä¸å›ºå®š | â€â€œ ç©ºä¸² | å­—ç¬¦ä¸² |

## 2.3.1 æ•´å‹

* æ•´å‹ï¼šint8ï¼Œint16ï¼Œint32ï¼Œint64
* æ— ç¬¦å·æ•´å‹ï¼šuint8ï¼Œuint16ï¼Œuint32ï¼Œuint64
* è‡ªåŠ¨åŒ¹é…æ“ä½œç³»ç»Ÿä½æ•°æ•´å‹ï¼šintï¼Œuint ï¼ˆåœ¨32ä½ç³»ç»Ÿï¼Œç›¸å½“äºint32å’Œuint32ï¼›åœ¨64ä½ç³»ç»Ÿç›¸å½“äºint64å’Œuint64ï¼‰

```go
var (
    a int8
    b int16
    c int32
    d int64
    e uint8
    f uint16
    g uint32
    h uint64
    i int
    j uint
)
```

**æ•´å‹å­—é¢é‡è¡¨ç¤ºå½¢å¼åˆ†ä¸‰ç§ï¼Œ10è¿›åˆ¶ï¼ˆdecimalï¼‰ã€8è¿›åˆ¶ï¼ˆoctalï¼‰å’Œ16è¿›åˆ¶ï¼ˆhexï¼‰**

```go
package main

import (
    "fmt"
    "reflect"
)

func main() {
    var a = 10  // 10è¿›åˆ¶æŒ‰ç…§æ­£å¸¸ä¹ æƒ¯è¡¨ç¤º
    var b = 012 // 8è¿›åˆ¶å¼€å¤´å¿…é¡»ä¸º0
    var c = 0xA // 16è¿›åˆ¶å¼€å¤´å¿…é¡»ä¸º0x

    fmt.Printf("%d %d %d\n",a, b, c) // 10 10 10
    fmt.Printf("%x %x %x\n",a, b, c) // a a a
    fmt.Printf("%o %o %o\n",a, b, c) // 12 12 12
    fmt.Printf("%b %b %b\n",a, b, c) // 1010 1010 1010

    ta := reflect.TypeOf(a)
    fmt.Println(ta.Kind()) // int  æ•´å‹å­—é¢é‡è‡ªåŠ¨æ¨æ–­ä¸ºintå‹

}
```

* æ•´å‹ä¸å­—ç¬¦ä¸²ç›¸äº’è½¬æ¢ä½¿ç”¨stringsã€strconvåŒ…ä¸­çš„å‡½æ•°

## 2.3.2 æµ®ç‚¹å‹

Goè¯­è¨€æµ®ç‚¹æ•°æ®æ ¼å¼éµå¾ªIEEE 754æ ‡å‡†

* float32
* float64

```go
var (
    a float32
    b float64
)
```

æµ®ç‚¹å‹å­—é¢é‡å½¢å¼ =  æ•´æ•°éƒ¨åˆ† + å°æ•°ç‚¹ + å°æ•°éƒ¨åˆ† + æŒ‡æ•°éƒ¨åˆ†

```go
package main

import (
    "fmt"
    "reflect"
)

func main() {
    var a = 1.234
    var b = 01.234
    var c = 1234e-3
    var d = 1234E-3
    var f = 0.1234e1
    var g = .1234e1

    fmt.Println(a,b,c,d,f,g) // 1.234 1.234 1.234 1.234 1.234 1.234

    ta := reflect.TypeOf(a)
    fmt.Println(ta.Kind()) // float64 æµ®ç‚¹å‹å­—é¢é‡è‡ªåŠ¨æ¨æ–­ä¸ºfloat64
}
```

* æ•´å‹ä¸å­—ç¬¦ä¸²ç›¸äº’è½¬æ¢ä½¿ç”¨stringsã€strconvåŒ…ä¸­çš„å‡½æ•°

## 2.3.3 å¤æ•°

* complex64
* complex128

å¤æ•°å­—é¢é‡å½¢å¼ = æµ®ç‚¹æ•° Â± æµ®ç‚¹æ•°i

complex64 = float32 Â± float32i

complex128 = float64 Â± float64i

**æ³¨æ„ï¼šè™šéƒ¨æµ®ç‚¹æ•°å’Œiä¹‹é—´æ²¡æœ‰ä»»ä½•å­—ç¬¦**

```
package main

import "fmt"

func main() {
    var a complex64 = 1 + 2i
    fmt.Println(a) // (1+2i)
    fmt.Println(real(a), imag(a)) // 1 2 å†…ç½®å‡½æ•°realå’Œimageä¸“é—¨ç”¨æ¥å–å¤æ•°çš„å®éƒ¨å’Œè™šéƒ¨
}
```

## 2.3.4 å¸ƒå°”å‹

```
var a, b = true, false
```

## 2.3.5 å­—ç¬¦

Goè¯­è¨€å­—ç¬¦åˆ†2ç§

* byteï¼ˆuint8çš„åˆ«åï¼Œå³byteå°±æ˜¯uint8ï¼‰ï¼Œä»£è¡¨ä¸€ä¸ª**å­—èŠ‚**
* runeï¼ˆint32çš„åˆ«åï¼Œå³runeå°±æ˜¯int32ï¼‰ï¼Œä»£è¡¨ä¸€ä¸ª**Unicodeå­—ç¬¦**ï¼Œå­˜å‚¨çš„æ•°å€¼ç­‰äºè¯¥å­—ç¬¦çš„Unicodeç çš„æ•°å€¼

æºç  [https://github.com/golang/go/blob/master/src/builtin/builtin.go](#) 85~92è¡Œ

```go
// byte is an alias for uint8 and is equivalent to uint8 in all ways. It is
// used, by convention, to distinguish byte values from 8-bit unsigned
// integer values.
type byte = uint8

// rune is an alias for int32 and is equivalent to int32 in all ways. It is
// used, by convention, to distinguish character values from integer values.
type rune = int32
```

```go
var a byte = 'a'
var b rune = 'ğŸ˜'
var c uint8 = 97
var d int32 = 128513

a == c // true
b == d // true
```

**Unicodeå­—ç¬¦é›†å’ŒUTFç¼–ç **

Goè¯­è¨€å†…ç½®æ”¯æŒUnicodeå­—ç¬¦é›†å’ŒUTF-8ã€UTF-16ç¼–ç ï¼Œé»˜è®¤ç¼–ç UTF-8

å­—ç¬¦é›† = ç¬¦å·é›†åˆ + ç¼–å·é›†åˆ + åŒå°„å…³ç³»f

ä¾‹å¦‚æˆ‘ä»¬å®šä¹‰äº†ä¸€ä¸ªä»…åŒ…å«5ä¸ªemojiè¡¨æƒ…çš„è‡ªå®šä¹‰å­—ç¬¦é›†

* ç¬¦å·é›†åˆ--- 5ä¸ªè¡¨æƒ…
* ç¼–å·é›†åˆ--- 5ä¸ªæ•°å­—
* åŒå°„å…³ç³»f--- å³ä¸€ä¸€æ˜ å°„å…³ç³»ï¼Œä¸€ä¸ªç¬¦å·æœ‰ä¸”ä»…æœ‰ä¸€ä¸ªç¼–å·å¯¹åº”ï¼Œä¸€ä¸ªç¼–å·ä¹Ÿæœ‰ä¸”ä»…æœ‰ä¸€ä¸ªç¬¦å·å¯¹åº”

| ç¬¦å·é›†åˆ | æ˜ å°„å…³ç³»f | ç¼–å·é›†åˆ |
| :---: | :---: | :---: |
| ğŸ˜ | ğŸ˜   &lt;=&gt; 128513 | 128513 |
| ğŸ˜‚ | ğŸ˜‚   &lt;=&gt; 128514 | 128514 |
| ğŸ˜ƒ | ğŸ˜ƒ   &lt;=&gt; 128515 | 128515 |
| ğŸ˜„ | ğŸ˜„   &lt;=&gt; 128516 | 128516 |
| ğŸ˜… | ğŸ˜…   &lt;=&gt; 128517 | 128517 |



Unicodeæ˜¯æœ€å¹¿æ³›ä½¿ç”¨çš„å­—ç¬¦é›†ï¼Œæˆªæ­¢20190507æ”¶å½•137,929ä¸ªå­—ç¬¦ï¼Œå‡ ä¹å®šä¹‰äº†ç›®å‰æ‰€æœ‰å›½å®¶æ–‡å­—å’Œå¸¸ç”¨çš„ç¬¦å·ï¼Œä¸Šè¿°è‡ªå®šä¹‰å­—ç¬¦é›†æ˜¯Unicodeçš„å­é›†ï¼Œä¹Ÿå³ğŸ˜åœ¨Unicodeçš„ç¼–å·å°±æ˜¯128513

[http://www.unicode.org/versions/Unicode12.1.0/](#)

Unicodeå­—ç¬¦é›†å¯ä»¥è¡¨ç¤ºä¸ºä¸‹é¢çš„è¡¨æ ¼

| ç¬¦å·é›†åˆ | æ˜ å°„å…³ç³»f | ç¼–å·é›†åˆ |
| :---: | :---: | :---: |
| Unicodeä¸­æŸä¸ªç¬¦å· | ç¬¦å·   &lt;=&gt; ç¼–å· | Unicodeä¸­æŸä¸ªç¼–å· |

å­—ç¬¦é›†åˆ†ä¸ºå¼€æ”¾å­—ç¬¦é›†å’Œå°é—­å­—ç¬¦é›†ï¼Œå¼€æ”¾å­—ç¬¦é›†å³æœªæ¥å¯èƒ½æ–°å¢å­—ç¬¦ï¼ˆå¦‚Unicodeï¼‰ï¼Œå°é—­å­—ç¬¦é›†ï¼ˆå¦‚ASCIIï¼‰å·²ç»å›ºå®šå­—ç¬¦é›†æœªæ¥ä¸ä¼šæ–°å¢å­—ç¬¦

**UTFå…¨ç§°Unicode Transformation Formatï¼Œå³Unicodeçš„ä¼ è¾“æ ¼å¼**

Goè¯­è¨€é»˜è®¤ç¼–ç UTF-8ï¼Œå†…ç½®æ”¯æŒUTF-16  
UTF-8\(8-bit Unicode Transformation Format\)  
UTF-16\(16-bit Unicode Transformation Format\)

ç”±äºæœ€ç»ˆåœ¨ç½‘ç»œè¿›è¡Œä¼ è¾“çš„æˆ–è€…å†™å…¥æ–‡ä»¶çš„æ•°æ®ï¼Œå®è´¨è¿˜æ˜¯ä¸€ä¸²01åºåˆ—ï¼ˆbitæµæˆ–byteæµï¼‰ï¼Œä¾‹å¦‚ä¼ è¾“ä¸€ä¸ªAç¬¦å·ï¼Œå®é™…æ˜¯ä¼ è¾“äº†ä¸€ä¸²è¡¨ç¤ºè¿™ä¸ªç¬¦å·çš„01åºåˆ—ï¼ˆåŒç†å­˜å‚¨åœ¨æ–‡ä»¶ä¹Ÿæ˜¯è¿™æ ·ï¼‰ï¼Œå‡å¦‚ä¸ä½¿ç”¨UTFç¼–ç ï¼Œé‚£ä¹ˆéœ€è¦ç›´æ¥ä¼ è¾“Açš„ç¼–å·65çš„äºŒè¿›åˆ¶å€¼ï¼ˆ00000000000000000000000001000001ï¼ŒGoä½¿ç”¨runeæ¥å­˜è¿™ä¸ªç¼–å·ï¼Œruneæ˜¯int32çš„åˆ«åï¼‰ï¼Œè¿™æ ·ä¼ è¾“å¤§å¤šæ•°å­—ç¬¦å‰é¢éƒ½ä¼ äº†ä¸€ä¸²æ²¡æ„ä¹‰çš„0ï¼Œæµªè´¹å¸¦å®½å’Œç©ºé—´

æ‰€ä»¥æœ‰äº†å˜é•¿ç¼–ç ï¼Œä»¥UTF8ä¸ºä¾‹è¯´æ˜

```go
package main

import (
    "fmt"
    "unicode/utf8"
)

func main() {
    var a = 'A'
    var b = 'ğŸ˜'
    fmt.Printf("%d %d\n", a, b) // 65 128513
    fmt.Printf("%032b %032b\n", a, b) // 00000000000000000000000001000001 00000000000000011111011000000001
    fmt.Printf("%U %U\n", a, b) // U+0041 U+1F601  Unicodeç¼–å· U+ 65å’Œ128513çš„16è¿›åˆ¶

    var aByte = make([]uint8, 1)  // æ³¨æ„ byteæ˜¯uint8çš„åˆ«åï¼ŒäºŒè€…å®Œå…¨ç­‰ä»·
    var bByte = make([]byte, 4 )
    utf8.EncodeRune(aByte, a)
    utf8.EncodeRune(bByte, b)
    fmt.Printf("%b %b\n", aByte, bByte) //[1000001] [11110000 10011111 10011000 10000001]

}
```

ä»ä¸Šé¢å¯ä»¥çœ‹å‡ºï¼Œç¬¦å·Aæœ€åå˜æˆäº†1ä¸ªbyteï¼Œç¬¦å·ğŸ˜è¿˜æ˜¯4ä¸ªbyteï¼Œåœ¨UTFç¼–ç ä¸­ä¼šå°†é«˜é¢‘ç¬¦å·ä½¿ç”¨æ›´å°‘byteç¼–ç ï¼Œä¸å¸¸ç”¨çš„ç¬¦å·åˆ™ä¼šä½¿ç”¨è¾ƒé•¿çš„byteç¼–ç ï¼ŒUTF-8ä¸­çš„8æ˜¯æŒ‡ç¼–ç çš„ç»“æœæœ€å°å•å…ƒæ˜¯8bitï¼ˆæˆ–è€…å«ç¼–ç ç»“æœçš„åŸºæœ¬å•ä½æ˜¯8bitï¼‰

æ‰€ä»¥å‡å¦‚è¿›ç¨‹1è¦å‘è¿›ç¨‹2å‘é€ä¸€ä¸ªç¬¦å·Aï¼Œé‚£ä¹ˆè¦ç»è¿‡ä»¥ä¸‹æ­¥éª¤ï¼ˆGoè¯­è¨€ï¼ŒUTF-8ç¼–ç ï¼‰

* è¿›ç¨‹1å£°æ˜å¹¶åˆå§‹åŒ–ç¬¦å·A  var msg = 'A' 
* è¿›ç¨‹1å°†Aè¿›è¡ŒUTF-8ç¼–ç ï¼ˆmsg-&gt; byte\[\]{65}ï¼‰
* è¿›ç¨‹1å°†byte\[\]{65}è¿›è¡Œä¼ è¾“
* è¿›ç¨‹2æ”¶åˆ°byte\[\]{65}
* è¿›ç¨‹2å°†byte\[\]{65}è¿›è¡ŒUTF-8è§£ç ï¼ˆbyte\[\]{65} -&gt; msg\)ï¼‰
* è¿›ç¨‹2è·å–åˆ°ç¬¦å·A

**è¡¨ç¤ºruneçš„å­—é¢é‡**

```
package main

import "fmt"

func main() {
    var a, b = 'A', 'ğŸ˜'                    // ç›´æ¥å†™ç¬¦å·
    var a1 = '\x41'                         // \x + 2ä½16è¿›åˆ¶æ•°å­—ï¼Œ1å­—èŠ‚ï¼Œä»…å¯è¡¨ç¤ºUnicodeä¸­UTF-8ç¼–ç åé•¿åº¦ä¸º1å­—èŠ‚çš„å­—ç¬¦ï¼Œï¼ˆASCIIå­—ç¬¦ï¼‰
    var a2 = '\101'                         // \  + 3ä½8 è¿›åˆ¶æ•°å­—ï¼Œ1å­—èŠ‚ï¼Œä»…å¯è¡¨ç¤ºUnicodeä¸­UTF-8ç¼–ç åé•¿åº¦ä¸º1å­—èŠ‚çš„å­—ç¬¦ï¼Œï¼ˆASCIIå­—ç¬¦ï¼‰
    var a3 = '\u0041'                       // \u + 4ä½16è¿›åˆ¶æ•°å­—ï¼Œ2å­—èŠ‚ï¼Œå¯è¡¨ç¤ºUnicodeä¸­UTF-8ç¼–ç åé•¿åº¦å°äºç­‰äº2å­—èŠ‚çš„å­—ç¬¦
    var a4, b4 = '\U00000041', '\U0001F601' // \U + 8ä½16è¿›åˆ¶æ•°å­—ï¼Œ4å­—èŠ‚ï¼Œå¯è¡¨ç¤ºUnicodeä¸­UTF-8ç¼–ç åçš„å…¨éƒ¨å­—ç¬¦ 
    // è¿™ç§æ˜¯Unicodeç¼–ç è§„èŒƒä¸­UCS-4è¡¨ç¤ºæ³•
    fmt.Printf("%c %c\n", a, b)
    fmt.Printf("%c\n", a1)
    fmt.Printf("%c\n", a2)
    fmt.Printf("%c\n", a3)
    fmt.Printf("%c %c\n", a4, b4)

    // è½¬ä¹‰å­—ç¬¦
    var c = '\t'
    var c1 = '\x09'
    var c2 = '\011'
    var c3 = '\u0009'
    var c4 = '\U00000009'
    fmt.Printf("å­—ç¬¦ï¼š%c æ•°å€¼%d Unicodeç %U\n", c, c, c)
    fmt.Printf("å­—ç¬¦ï¼š%c æ•°å€¼%d Unicodeç %U\n", c1, c1, c1)
    fmt.Printf("å­—ç¬¦ï¼š%c æ•°å€¼%d Unicodeç %U\n", c2, c2, c2)
    fmt.Printf("å­—ç¬¦ï¼š%c æ•°å€¼%d Unicodeç %U\n", c3, c3, c3)
    fmt.Printf("å­—ç¬¦ï¼š%c æ•°å€¼%d Unicodeç %U\n", c4, c4, c4)

    var d = '\\'
    var d1 = '\x5c'
    var d2 = '\134'
    var d3 = '\u005c'
    var d4 = '\U0000005c'
    fmt.Printf("å­—ç¬¦ï¼š%c æ•°å€¼%d Unicodeç %U\n", d, d, d)
    fmt.Printf("å­—ç¬¦ï¼š%c æ•°å€¼%d Unicodeç %U\n", d1, d1, d1)
    fmt.Printf("å­—ç¬¦ï¼š%c æ•°å€¼%d Unicodeç %U\n", d2, d2, d2)
    fmt.Printf("å­—ç¬¦ï¼š%c æ•°å€¼%d Unicodeç %U\n", d3, d3, d3)
    fmt.Printf("å­—ç¬¦ï¼š%c æ•°å€¼%d Unicodeç %U\n", d4, d4, d4)
}
// Output
A ğŸ˜
A
A
A
A ğŸ˜
å­—ç¬¦ï¼š  æ•°å€¼9 Unicodeç U+0009
å­—ç¬¦ï¼š  æ•°å€¼9 Unicodeç U+0009
å­—ç¬¦ï¼š  æ•°å€¼9 Unicodeç U+0009
å­—ç¬¦ï¼š  æ•°å€¼9 Unicodeç U+0009
å­—ç¬¦ï¼š  æ•°å€¼9 Unicodeç U+0009
å­—ç¬¦ï¼š\ æ•°å€¼92 Unicodeç U+005C
å­—ç¬¦ï¼š\ æ•°å€¼92 Unicodeç U+005C
å­—ç¬¦ï¼š\ æ•°å€¼92 Unicodeç U+005C
å­—ç¬¦ï¼š\ æ•°å€¼92 Unicodeç U+005C
å­—ç¬¦ï¼š\ æ•°å€¼92 Unicodeç U+005C
```

æ³¨ï¼šä¸Šè¿°æ¦‚å¿µæ›´ä¸“ä¸šä¸€ç‚¹çš„è¯´æ³•

å­—ç¬¦é›† = æŠ½è±¡å­—ç¬¦é›†åˆ + æ˜ å°„è§„åˆ™ + ç ä½é›†åˆ

ç ä½ => è¿›è¡Œutf-8/16ç¼–ç  => ç å…ƒä¸º8/16bitçš„ç å…ƒåºåˆ—

ç å…ƒåºåˆ— => utf-8/16è§£ç  => ç ä½


**è½¬ä¹‰å­—ç¬¦çš„ä½œç”¨ï¼š**

* è¡¨ç¤ºå­—ç¬¦é›†ä¸­æ²¡æœ‰å›¾å½¢çš„å­—ç¬¦ï¼ˆä¾‹å¦‚æ¢è¡Œç¬¦ï¼Œå®é™…ä¸Šæ²¡æœ‰ä¸€ä¸ªå…·ä½“çš„å›¾å½¢å¯¹åº”è¿™ä¸ªç¬¦å·ï¼Œåªèƒ½ç”¨\nè¡¨ç¤ºï¼‰
* è¡¨ç¤ºæŸç§è®¡ç®—æœºè¯­è¨€ä¸­è¢«å®šä¹‰ä¸ºç‰¹æ®Šç”¨é€”çš„å­—ç¬¦ï¼ˆä¾‹å¦‚\ï¼Œå› ä¸ºå®šä¹‰ä¸ºç‰¹æ®Šå«ä¹‰--è½¬ä¹‰å­—ç¬¦èµ·å§‹æ ‡å¿—ï¼‰
* ç”¨å­—ç¬¦çš„ç¼–å·æ¥è¡¨ç¤ºå­—ç¬¦

Goè¯­è¨€å¸¸è§è½¬ä¹‰å­—ç¬¦å¦‚ä¸‹ï¼š

```

```

https://apps.timwhitlock.info/emoji/tables/unicode emojiè¡¨æƒ…çš„Unicodeç å…ƒå€¼

## 2.3.6 å­—ç¬¦ä¸²

å­—ç¬¦ä¸²åœ¨Goè¯­è¨€ä¸­æ˜¯åŸç”Ÿæ•°æ®ç±»å‹ï¼Œå’Œå…¶ä»–æ•´å‹ã€æµ®ç‚¹å‹ã€å¸ƒå°”å‹åŸç”Ÿç±»å‹ä¸€è‡´ï¼Œå¯ä»¥ç›´æ¥ä½¿ç”¨

å­—ç¬¦ä¸²å­—é¢é‡2å„ç§å½¢å¼

* åŒå¼•å·""ï¼Œè½¬ä¹‰å­—ç¬¦æœ‰æ•ˆï¼Œå•è¡Œ
* åå¼•å·\`\`ï¼Œè½¬ä¹‰å­—ç¬¦æ— æ•ˆï¼Œå¯å¤šè¡Œï¼Œå¤šè¡Œç›¸å½“äºè¡Œå°¾æœ‰ä¸€ä¸ªæ¢è¡Œç¬¦

```go
package main

import "fmt"

func main() {  
    var a = "a\nbcd\n ef"  
    var b = `a              
bcd              
 ef`  
    var c = `a\nbcd\n ef`  
    fmt.Println(a)  
    fmt.Println(b)  
    fmt.Println(c)  
}  
// Output:  
a  
bcd  
 ef  
a  
bcd  
 ef

a\nbcd\n ef
```

çœ‹ä¸‹é¢å‡ ä¸ªå­—ç¬¦ä¸²å®é™…å†…å­˜å­˜å‚¨ç»“æ„

```
var s = "hello, world"
hello := s[:5]
world := s[7:]
```

![](/assets/stringçš„åº•å±‚ç»“æ„.png)

![](/assets/stringçš„åº•å±‚ç»“æ„2.png)

å®é™…stringå°±æ˜¯ä¸€ä¸ªstructï¼ŒåŒ…å«ä¸€ä¸ªæŒ‡é’ˆå’Œä¸€ä¸ªé•¿åº¦ï¼ŒæŒ‡é’ˆæŒ‡å‘çš„æ˜¯ä¸å¯å¤–éƒ¨è¯»å–å’Œæ“ä½œçš„\[\]byteï¼Œåœ¨ä¸Šé¢å›¾ä¸­ä¸€ä¸ªæ ¼å­ä»£è¡¨ä¸€ä¸ªå­—èŠ‚ï¼Œå½“ç„¶å®é™…å­˜å‚¨çš„æ˜¯8ä½01åºåˆ—  
stringåœ¨æºç ä¸­å¯¹åº”çš„ç»“æ„å¦‚ä¸‹ï¼š

```
type stringStruct struct {
    str unsafe.Pointer
    len int
}
// /src/runtime/string.go line 213
```

* æŒ‡å‘\[\]byteçš„ä¸€ä¸ªæŒ‡é’ˆï¼Œå¯ä»¥æŒ‡å‘\[\]byteä¸­åˆæ³•çš„ä»»æ„ä½ç½®ï¼Œç›¸å½“ä¸€ä¸ªèµ·å§‹ä¸‹æ ‡

* é•¿åº¦ï¼Œå³ä»èµ·å§‹ä¸‹æ ‡å¼€å§‹ä¸€å…±å¤šå°‘ä¸ªbyteå±äºè¿™ä¸ªå­—ç¬¦ä¸²

stringä¸å¯å˜å¯ä»¥ç†è§£ä¸ºï¼š

* å³å¤–éƒ¨æ²¡æœ‰ä»»ä½•æ–¹æ³•å¯ä»¥ä¿®æ”¹æŒ‡å‘çš„stræŒ‡å‘\[\]byteçš„ä½ç½®å’Œlençš„æ•°å€¼
* åŒæ—¶Goè¯­è¨€åº”ä¿è¯stræŒ‡å‘çš„\[\]byteæ˜¯ä¸å¯å˜çš„ï¼Œä½†å¯èƒ½å…è®¸appendï¼ŸGoè¯­è¨€å­˜å‚¨å­—ç¬¦ä¸²å­—é¢é‡æ˜¯ç”¨ä¸€ä¸ªè¶…é•¿\[\]byteä¹ˆï¼Ÿ

**æ³¨æ„ï¼š**

```go
package main

import (
    "fmt"
    "reflect"
    "unicode/utf8"
)

func main() {
    var str = "abcéƒ­ä¸€é¸£"
    var byteLength = len(str)
    var runeLength = utf8.RuneCountInString(str)
    blt := reflect.TypeOf(byteLength)
    rlt := reflect.TypeOf(runeLength)
    fmt.Println(byteLength, blt.Kind()) // 12 int 
    // len(string) è¿”å›byteé•¿åº¦

    fmt.Println(runeLength, rlt.Kind()) // 6 int 
    // utf8.RuneCountInString(string)ï¼Œè¿”å›stringæŒ‡å‘çš„[]byte UTF-8è§£ç åçš„[]runeçš„é•¿åº¦

    for i := 0 ; i < len(str); i++ {
        if i == 0 {
            t := reflect.TypeOf(str[i])
            fmt.Printf("%s ", t.Kind())
        }
        fmt.Printf("%c", str[i])
    }
    // uint8 abcÃ©ÂƒÂ­Ã¤Â¸Â€Ã©Â¸Â£  è¾“å‡ºä¹±ç ï¼Œéå†çš„æ˜¯å­—ç¬¦ä¸²çš„æ¯ä¸ªbyteï¼Œå°†æ¯ä¸ªbyteè¿›è¡ŒUTF-8è§£ç 
    // åªèƒ½è§£ç å‡ºUnicodeå­—ç¬¦é›†ä¸­å¯¹åº”UTF-8ç¼–ç ç»“æœä¸ºå•ä¸ªbyteçš„å­—ç¬¦
    fmt.Println()
    for i, v := range str {
        if i == 0 {
            t := reflect.TypeOf(v)
            fmt.Printf("%s ", t.Kind())
        }
        fmt.Printf("%c",v)
    }
    // int32 abcéƒ­ä¸€é¸£ è¾“å‡ºæ­£å¸¸ï¼Œéå†çš„æ˜¯stringæŒ‡å‘çš„[]byte UTF-8è§£ç åçš„[]rune
}
```

**ä»æ±‡ç¼–æŸ¥æºç 1ï¼š**

```go
package main

import (
    "fmt"
)

func main() {
    var str = "abcéƒ­ä¸€é¸£"

    for _, v := range str {

        fmt.Printf("%c",v)
    }
}
```

ä»æ±‡ç¼–ä¿¡æ¯å¯ä»¥çœ‹å‡ºåœ¨rangeçš„æ—¶å€™è°ƒç”¨äº†runtime.decoderune\(SB\)

```assembly
...
CALL runtime.decoderune(SB) // (*)
...
```

**ä»æ±‡ç¼–æŸ¥æºç 2ï¼š**  
é€šè¿‡\[\]byteç”Ÿæˆä¸€ä¸ªå­—ç¬¦ä¸²ä»£ç å¦‚ä¸‹

```
package main

import "fmt"

func main() {
    b := make([]byte, 10)
    fmt.Println(string(b))
}
```

```
go build -gcflags -S xxx.go // è·å–æ±‡ç¼–ä¿¡æ¯
```

```
...
CALL    runtime.slicebytetostring(SB) //æ±‡ç¼–å†…å®¹
...
```

```
// []byteç”Ÿæˆå­—ç¬¦ä¸²é€»è¾‘
// Buf is a fixed-size buffer for the result,
// it is not nil if the result does not escape.
func slicebytetostring(buf *tmpBuf, b []byte) (str string) {
    l := len(b)
    if l == 0 {
        // Turns out to be a relatively common case.
        // Consider that you want to parse out data between parens in "foo()bar",
        // you find the indices and convert the subslice to string.
        return ""
    }
    if raceenabled {
        racereadrangepc(unsafe.Pointer(&b[0]),
            uintptr(l),
            getcallerpc(),
            funcPC(slicebytetostring))
    }
    if msanenabled {
        msanread(unsafe.Pointer(&b[0]), uintptr(l))
    }
    if l == 1 {
        stringStructOf(&str).str = unsafe.Pointer(&staticbytes[b[0]])
        stringStructOf(&str).len = 1
        return
    }

    var p unsafe.Pointer
    if buf != nil && len(b) <= len(buf) {
        p = unsafe.Pointer(buf)
    } else {
        p = mallocgc(uintptr(len(b)), nil, false)
    }
    stringStructOf(&str).str = p
    stringStructOf(&str).len = len(b)
    memmove(p, (*(*slice)(unsafe.Pointer(&b))).array, uintptr(len(b)))
    return
}
// /src/runtime/string.go line 75
```

## 2.3.7 æŒ‡é’ˆ

æ­£å¸¸å¼€å‘ä¸ä¼šä½¿ç”¨ï¼Œæ˜¯Goè¯­è¨€æºç å†…éƒ¨åœ°å€è¿ç®—ä½¿ç”¨çš„ä¸€ç§ç±»å‹

```
// uintptr is an integer type that is large enough to hold the bit pattern of
// any pointer.
type uintptr uintptr
```

## 2.3.8 å„ä¸ªç±»å‹çš„é›¶å€¼

æ¯ç§ç±»å‹éƒ½æœ‰ä¸€ä¸ªé›¶å€¼ã€‚ä¸€ä¸ªç±»å‹çš„é›¶å€¼å¯ä»¥çœ‹ä½œæ˜¯æ­¤ç±»å‹çš„é»˜è®¤å€¼ã€‚

* å¸ƒå°”ç±»å‹çš„é›¶å€¼æ˜¯falseã€‚
* æ•°å€¼ç±»å‹çš„é›¶å€¼éƒ½æ˜¯é›¶ï¼ˆä½†ä¸åŒçš„æ•°å€¼ç±»å‹çš„é›¶æ˜¯ä¸åŒçš„ï¼‰ã€‚
* å­—ç¬¦ä¸²ç±»å‹çš„é›¶å€¼æ˜¯ä¸€ä¸ªç©ºå­—ç¬¦ä¸²""ã€‚



